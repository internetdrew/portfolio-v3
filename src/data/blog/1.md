---
title: "Building a Supabase-powered React, Express, and tRPC Full-Stack App From 0 to Prod"
description: "Everything you need to know to get started with Supabase, including how to set up local development, use SDKs with row-level security and more."
pubDate: 2025-07-08
ogImageSrc: "0-opengraph.png"
isDraft: true
---

## Table of Contents

Supabase is one of the things I adopted early in my programming journey. It's a great Backend-as-a-Service that allows your to build quickly and easily integrate a Postgres database, object storage and more.

I'm writing this for others to be able to easily get started and avoid some of the confusing bits of going back and forth through the docs.

## Why I'm Creating This

I love using Supabase. Even though I've been using it for some time and the docs are pretty good, there are some simple nuances that you can easily miss that have burned hours of my time. So I'm writing this so someone can easily walk through this process to get things up and running.

The table of contents is clickable, so feel free to skip to a part you need if you've already got something I'm covering here.

## What We're Building

To walk through this, we will build a simple full-stack app with a React front-end and an Express back-end. Doing this is important because there are little nuances of bringing this stack to life that can be a bit challenging to bring to production.

I will also be building this app with tRPC, which is great for having end-to-end type-safety throughout your application. You can skip this part if you want to use something else, but wow, I love using this to move quickly without breaking things and it's a valuable part of my personal stack that I encourage others to at least try.

## What We're Using

- [Vite-based React](https://vite.dev/guide/)
- [Supabase](https://supabase.com/) (Postgres, Google Auth, JavaScript SDK)
- [tRPC](https://trpc.io/)
- [Express](https://expressjs.com/)
- [Vercel](https://vercel.com/) (Serverless-deployment and how to make what works in development work in production)

Let's get started.

## Creating the Stack

### Prerequisites

- [Node.JS](https://nodejs.org/en/download) (stick with LTS for this, through whatever Node Version Manager you use)
- [Docker](https://www.docker.com/) or some alternative (needed for Supabase local environment)

**Note:** Vite's latest needs a Node version greater than `20.19.0` or greater than/equal to `22.12.0` at the time of writing this.

### Setting Up the Frontend

To get started, let's get our Vite-based React front-end going. If you're thinking, _"What about create-react-app?"_, you can [learn more here](https://react.dev/blog/2025/02/14/sunsetting-create-react-app).

### Building the Front-end

In the root of the project:

```bash
npm create vite@latest .
```

When prompted to select a framework, choose `React` and then either TypeScript or TypeScript + [SWC](https://swc.rs/).

Now you just need to install deps with and bring the dev server up:

```bash
npm install && npm run dev
```

You should now be able to see your initial app up at [http://localhost:5173](http://localhost:5173/)

### Building the Back-end

Let's create a separate directory for our backend and set up its dependencies:

```bash
mkdir server
cd server
npm init -y
npm install express cors dotenv cookie-parser
npm install --save-dev typescript @types/express @types/cors @types/node tsx nodemon @types/cookie-parser
```

Now let's set up the root package.json to run both frontend and backend together. Go back to the root directory and install concurrently:

```bash
cd ..
npm install --save-dev concurrently
```

This keeps our frontend and backend dependencies separate, which is important for:

- **Security**: Backend-only packages don't get bundled with frontend
- **Build process**: Frontend and backend have different build steps
- **Development**: Easier to run frontend dev server and backend API separately
- **Dependency management**: Avoid version conflicts between frontend and backend packages

Even though we'll deploy this as a single full-stack application, keeping dependencies separate makes the build and development process much cleaner.

Now let's set up TypeScript configuration. Create `server/tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

Now let's create our basic Express server:

```bash
# Create the source directory and main server file
mkdir server/src
touch server/src/index.ts
```

Now let's make a `.env` file at the root of our app to hold our secret variables. We will need this later for Supabase.

```bash
touch .env
```

And now within our `.gitignore`, add `.env` and save. This will keep up from accidentally committing any sensitive variables to our repo, where others may be able to exploit them.

```typescript
import express, { Request, Response } from "express";
import cors from "cors";
import dotenv from "dotenv";
import path from "path";

// Load .env file from the project root (one level up from server directory)
// We will use this for important variables later once we connect with Supabase
dotenv.config({ path: path.resolve(__dirname, "../../.env") });

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());

// Basic health check route
app.get("/api/health", (req: Request, res: Response) => {
  res.json({ status: "ok", message: "Server is running!" });
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

Let's also set up the package.json scripts. Update `server/package.json`:

```json
{
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "nodemon --exec tsx src/index.ts"
  }
}
```

Create `server/nodemon.json` for better development experience:

```json
{
  "watch": ["src"],
  "ext": "ts",
  "ignore": ["src/**/*.spec.ts"],
  "exec": "tsx ./src/index.ts"
}
```

Now let's update the root `package.json` to add scripts that run both servers. Add these scripts to your root `package.json`, With `concurrently`, we're able to name our terminal output and color code them for easy debugging as we bring them up together:

```json
{
  "scripts": {
    "dev": "concurrently -n \"client,server\" -c \"blue,green\" \"npm run dev:frontend\" \"npm run dev:backend\"",
    "dev:frontend": "vite",
    "dev:backend": "cd server && npm run dev",
    "build": "npm run build:frontend && npm run build:backend",
    "build:frontend": "vite build",
    "build:backend": "cd server && npm run build"
  }
}
```

Now you can start both servers with one command:

```bash
npm run dev
```

This will start:

- **Frontend** at [http://localhost:5173](http://localhost:5173)
- **Backend** at [http://localhost:3000](http://localhost:3000)

You can test the backend health endpoint at [http://localhost:3000/api/health](http://localhost:3000/api/health).

With TypeScript, we now have:

- **Type safety** between frontend and backend
- **Better IDE support** with autocomplete and error detection
- **Easier refactoring** with confidence
- **Shared types** that can be used across frontend and backend (we'll set this up with tRPC later)

Now that we have our stack up and running, it's time to connect them both with tRPC. This will allow us to easily know we are passing the right things to the back-end from the front-end and getting back from the backend what we expect on the front-end. Make a mistake? Your IDE will warn you.

## Connecting the Stack with tRPC for End-to-End Type-Safety

### Server Setup

First, let's install what we need for both the server and the client.

In the root of the app (wherever your client/front-end code lives):

```bash
npm i @trpc/client
```

In the `server` directory:

```bash
npm i @trpc/server
```

We can then make a file for our tRPC router:

```bash
touch server/src/trpc.ts
```

```typescript
import { initTRPC } from "@trpc/server";

export const createContext = async () => {
  return {};
};

type Context = Awaited<ReturnType<typeof createContext>>;

/**
 * Initialization of tRPC backend
 * Should be done only once per backend!
 */
const t = initTRPC.context<Context>().create();

/**
 * Export reusable router and procedure helpers
 * that can be used throughout the router
 */
export const router = t.router;
export const publicProcedure = t.procedure;
```

Then in our `server/src/index.ts` file where our Express instance lives:

```typescript
import z from "zod";
import express, { Request, Response } from "express";
import { createExpressMiddleware } from "@trpc/server/adapters/express";
import cors from "cors";
import dotenv from "dotenv";
import path from "path";
import cookieParser from "cookie-parser";
import { router, createContext, publicProcedure } from "./trpc";

dotenv.config({ path: path.resolve(__dirname, "../../.env") });

const app = express();
const PORT = process.env.PORT || 3000;

export const appRouter = router({
  sayHello: publicProcedure
    .input(z.object({ name: z.string() }))
    .query(async ({ input }) => {
      return `hello ${input.name}`;
    }),
});

const corsOptions = {
  origin: "http://localhost:5173",
  credentials: true,
};

app.use(cors(corsOptions));
app.use(express.json());
app.use(cookieParser());

app.get("/api/health", (req: Request, res: Response) => {
  res.json({ status: "ok", message: "Server is running!" });
});

app.use(
  "/trpc",
  createExpressMiddleware({
    router: appRouter,
    createContext,
    onError: ({ error }) => {
      console.error(error);
    },
  }),
);

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

export default app;

export type AppRouter = typeof appRouter;
```

This is essentially all you need for the basic tRPC server setup. Now let's reach for our query from the front-end.

### Client Setup

You can decide on this via the tRPC docs, but I use [their approach with TanStack Query](https://trpc.io/docs/client/tanstack-react-query/setup).

First, let's install the dependencies we need:

```bash
npm i @trpc/tanstack-react-query @tanstack/react-query
```

Then make our client-side tRPC file:

```bash
touch src/trpc.ts
```

And in there:

```typescript
import { QueryClient } from "@tanstack/react-query";
import { createTRPCOptionsProxy } from "@trpc/tanstack-react-query";
import type { AppRouter } from "../server/src/index";
import { createTRPCClient, httpBatchLink } from "@trpc/client";

export const queryClient = new QueryClient();

// Docs say localhost:3000 but I like to use server proxy with vite to bring things together seamlessly.
// That will come soon.
const trpcClient = createTRPCClient<AppRouter>({
  links: [httpBatchLink({ url: "/trpc" })],
});

export const api = createTRPCOptionsProxy<AppRouter>({
  client: trpcClient,
  queryClient,
});
```

**Warning:** In this next code snipped, we're doing it this way because we are building an SPA so we need the singleton approach. If you're using an SSR framework, you'll need to [follow this path](https://trpc.io/docs/client/tanstack-react-query/setup#3a-setup-the-trpc-context-provider).

Now, we need to wrap our app with the query client provider. In `main.tsx`:

```tsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import App from "./App.tsx";
import { queryClient } from "./trpc";
import { QueryClientProvider } from "@tanstack/react-query";

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
    </QueryClientProvider>
  </StrictMode>,
);
```

Next we give Vite the server proxy to send calls for `/trpc` to `localhost:3000`. So in `vite.config.ts`:

```typescript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react-swc";

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      "/trpc": {
        target: "http://localhost:3000",
        changeOrigin: true,
      },
    },
  },
});
```

And now in `App.tsx`:

```typescript
import './App.css';
import { api } from './trpc';
import { useQuery } from '@tanstack/react-query';

function App() {
  const { data } = useQuery(api.sayHello.queryOptions({ name: 'Mr. X' }));

  return (
    <>
      <p>{data}</p>
    </>
  );
}

export default App;
```

If you look at your monitor, you should now see "Hello John Wick". Go ahead and change it and see it update. You now have end-to-end type-safety.
