---
title: "Building a Supabase-powered React & Express Full-Stack App From 0 to Prod"
description: "Everything you need to know to get started with Supabase, including how to set up local development, use SDKs with row-level security and more."
pubDate: 2025-07-08
ogImageSrc: "0-opengraph.png"
isDraft: true
---

## Table of Contents

Supabase is one of the things I adopted early in my programming journey. It's a great Backend-as-a-Service that allows your to build quickly and easily integrate a Postgres database, object storage and more.

I'm writing this for others to be able to easily get started and avoid some of the confusing bits of going back and forth through the docs.

## Why I'm Creating This

I love using Supabase. Even though I've been using it for some time and the docs are pretty good, there are some simple nuances that you can easily miss that have burned hours of my time. So I'm writing this so someone can easily walk through this process to get things up and running.

The table of contents is clickable, so feel free to skip to a part you need if you've already got something I'm covering here.

## What We're Building

To walk through this, we will build a simple full-stack app with a React front-end and an Express back-end. Doing this is important because there are little nuances of bringing this stack to life that can be a bit challenging to bring to production.

I will also be building this app with tRPC, which is great for having end-to-end type-safety throughout your application. You can skip this part if you want to use something else, but wow, I love using this to move quickly without breaking things and it's a valuable part of my personal stack that I encourage others to at least try.

## What We're Using

- [Vite-based React](https://vite.dev/guide/)
- [Supabase](https://supabase.com/) (Postgres, Google Auth, JavaScript SDK)
- [tRPC](https://trpc.io/)
- [Express](https://expressjs.com/)
- [Vercel](https://vercel.com/) (Serverless-deployment and how to make what works in development work in production)

Let's get started.

## Creating the Stack

### Prerequisites

- [Node.JS](https://nodejs.org/en/download) (stick with LTS for this, through whatever Node Version Manager you use)
- [Docker](https://www.docker.com/) or some alternative (needed for Supabase local environment)

**Note:** Vite's latest needs a Node version greater than `20.19.0` or greater than/equal to `22.12.0` at the time of writing this.

### Setting Up the Frontend

To get started, let's get our Vite-based React front-end going. If you're thinking, _"What about create-react-app?"_, you can [learn more here](https://react.dev/blog/2025/02/14/sunsetting-create-react-app).

### Building the Front-end

In the root of the project:

```bash
npm create vite@latest .
```

When prompted to select a framework, choose `React` and then either TypeScript or TypeScript + [SWC](https://swc.rs/).

Now you just need to install deps with and bring the dev server up:

```bash
npm install && npm run dev
```

You should now be able to see your initial app up at [http://localhost:5173](http://localhost:5173/)

### Building the Back-end

Let's create a separate directory for our backend and set up its dependencies:

```bash
mkdir server
cd server
npm init -y
npm install express cors dotenv
npm install --save-dev typescript @types/express @types/cors @types/node tsx nodemon
```

Now let's set up the root package.json to run both frontend and backend together. Go back to the root directory and install concurrently:

```bash
cd ..
npm install --save-dev concurrently
```

This keeps our frontend and backend dependencies separate, which is important for:

- **Security**: Backend-only packages don't get bundled with frontend
- **Build process**: Frontend and backend have different build steps
- **Development**: Easier to run frontend dev server and backend API separately
- **Dependency management**: Avoid version conflicts between frontend and backend packages

Even though we'll deploy this as a single full-stack application, keeping dependencies separate makes the build and development process much cleaner.

Now let's set up TypeScript configuration. Create `server/tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

Now let's create our basic Express server:

```bash
# Create the source directory and main server file
mkdir server/src
touch server/src/index.ts
```

```typescript
import express, { Request, Response } from "express";
import cors from "cors";
import dotenv from "dotenv";

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());

// Basic health check route
app.get("/api/health", (req: Request, res: Response) => {
  res.json({ status: "ok", message: "Server is running!" });
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

Let's also set up the package.json scripts. Update `server/package.json`:

```json
{
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "nodemon --exec tsx src/index.ts"
  }
}
```

Create `server/nodemon.json` for better development experience:

```json
{
  "watch": ["src"],
  "ext": "ts",
  "ignore": ["src/**/*.spec.ts"],
  "exec": "tsx ./src/index.ts"
}
```

Now let's update the root `package.json` to add scripts that run both servers. Add these scripts to your root `package.json`, With `concurrently`, we're able to name our terminal output and color code them for easy debugging as we bring them up together:

```json
{
  "scripts": {
    "dev": "concurrently -n \"client,server\" -c \"blue,green\" \"npm run dev:frontend\" \"npm run dev:backend\"",
    "dev:frontend": "vite",
    "dev:backend": "cd server && npm run dev",
    "build": "npm run build:frontend && npm run build:backend",
    "build:frontend": "vite build",
    "build:backend": "cd server && npm run build"
  }
}
```

Now you can start both servers with one command:

```bash
npm run dev
```

This will start:

- **Frontend** at [http://localhost:5173](http://localhost:5173)
- **Backend** at [http://localhost:3000](http://localhost:3000)

You can test the backend health endpoint at [http://localhost:3000/api/health](http://localhost:3000/api/health).

With TypeScript, we now have:

- **Type safety** between frontend and backend
- **Better IDE support** with autocomplete and error detection
- **Easier refactoring** with confidence
- **Shared types** that can be used across frontend and backend (we'll set this up with tRPC later)
