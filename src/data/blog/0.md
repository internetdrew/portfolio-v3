---
title: "Bringing Where's the Garlic?! to Life"
description: "Sharing the journey of building an app for home grocery inventory management."
pubDate: 2025-05-15
ogImageSrc: "0-og.png"
isDraft: true
---

## Table of Contents

## What I'm Building and Why

I'm building [Where's the Garlic?!](https://app.wheresthegarlic.com), a home kitchen management app for organized foodies who live and cook together. I'm building this because there have been countless times when my partner and I have gotten to the supermarket and neither of us is completely sure how we are on groceries, what we're almost out of, and we have an excess of, etc.

As someone mildly organized in a relationship with someone who is wildly organized, I figured I'd have fun building an app that keeps us on the same page with ease.

## About the App
To address the problem of not knowing how we are on groceries, the app will be our home for what items we track on a regular basis and their current status.

We want to be able to do 3 things with this app to start:

1. **Keep track of items based on quantity, status, and sometimes both**. The statuses should be simple but dynamic. Some items, like bagels, are tracked by quantity. Some items, like a gallon of milk (which we typically only have one of), are tracked by status (full, halfway, almost out, done). Some items need both because we might have a few at once, so we track both how many and whether the last one is almost gone.


2. **Automatically generate a shopping list based on thresholds**. A large part of having this is that we also have a general idea of when we want to get more of an item. So the app will take in item thresholds that allow us to have automatically generated shopping lists based on the items that are being tracked. This will make it easy to go to the supermarket without needing to make a list because eggs were automatically added to the shopping list once we had 6 or less, for example.

3. **Work together to keep track of items**. The inherent challenge of building something like this is that people have to actually use it, which is difficult if you're not the one dealing with the annoyance. So I want to make this easy to use and as frictionless as possible. We'll need an invite system get others in the household involved. I'm curious to see if this takes off and we can use this when we have weeklong family vacations with 10 to 15 people.

## Tech Stack

- [Vite](https://vite.dev/guide/) for lightning-fast builds and local development  
  - Paired with [TypeScript](https://www.typescriptlang.org/) for static typing and better DX  
  - Uses [SWC](https://swc.rs/) for fast transpilation
- [React 19](https://react.dev/) for a modern, component-based UI architecture  
- [shadcn/ui](https://ui.shadcn.com/) for accessible, pre-built components styled with [Tailwind CSS](https://tailwindcss.com/) 
- [tRPC](https://trpc.io/) to enable end-to-end type-safe APIs without code duplication
- [Zod](https://zod.dev/) for runtime validation and schema inference, used with tRPC and form data
- [TanStack Query](https://tanstack.com/query/latest) to handle client-side data fetching, caching, and syncing  
- [React Router](https://reactrouter.com/) for declarative client-side routing
- [Express](https://expressjs.com/) as a lightweight, flexible Node.js backend  
- PostgreSQL, managed via [Supabase](https://supabase.com/) for relational data, auth, and storage
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/) for testing UI components based on real user interactions
- [Vitest](https://vitest.dev/) for fast, Vite-native testing with first-class TypeScript support and great DX



## Building a Local-First Web App

I recently stumbled across a subreddit people were sharing that there are many products that they don't try simply because the app is behind a sign up. And they'll walk away quickly before giving up their email address to use something they're not even sure if they will like or want.

Requiring authentication upfront could turn away users who might otherwise love the app, since they hit a login wall before seeing what it does.

User experience a critical factor here because it might directly impact adoption. So, while it's surely more work up-front, I believe the right move is to make it as easy as possible for people to play with the app to see if it's what they're looking for.

I've never built an app that would do this before. Most times, I build apps behind authentication to be able save to a database or object storage. You don't just want that exposed. But in the event of a local-first web app, one that needs to be able to save and organize possibly many values (one could add very many items!), I need to write operations that save to either a local database if the user is not authenticated or the remote database if the user is authenticated.

To handle local data storage, I turned to [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API), a lightweight database that runs right in the browser and lets users save data without needing to sign up. Even better than IndexedDB itself was discovering [Dexie](https://dexie.org/), a wrapper library that let me move faster without getting bogged down in verbose web API syntax.

Dexie allowed me to move very quickly on creating tables and indexing things I'd be using in queries:

```typescript
import Dexie, { type EntityTable } from "dexie";
import type { Tables } from "@/database.types";

type Household = Tables<"households">;
/*
type Household = {
    created_at: string;
    creator_id: string;
    id: string;
    title: string;
    updated_at: string;
}
*/

// Creates a new database named WTGarlic
// Adds a table named households with the type and id as the primary key
const dexie = new Dexie("WTGarlic") as Dexie & {
  households: EntityTable<Household, "id">;
};

// Tells Dexie which columns to index for queries
dexie.version(1).stores({
  households: "id, title, created_at, creator_id, updated_at",
});

export type { Household };
export { dexie };
```

This is the first pass at splitting logic based on auth: if the user is logged in, we send the data to the backend. If not, we save it locally with IndexedDB.

```typescript
const onSubmit = async (values: z.infer<typeof formSchema>) => {
  try {
    if (user) {
      // Use our tRPC mutation to hit the backend
      await createHouseholdMutation.mutateAsync(values);
    } else {
      // save to IndexedDB
      await dexie.households.add({
        id: crypto.randomUUID(),
        created_at: new Date().toISOString(),
        creator_id: "local-user",
        title: values.name,
        updated_at: new Date().toISOString(),
      });
    }
    onSuccess();
  } catch (error) {
    console.error("Failed to save household:", error);
  }
};
```

## Creating Context on Active Households

Once the household is added, we want to be able to identify the initial household as the active one.

Just about everything in this application will be dependent on which household is active. When users change the active household, you'll want all of the app data to update to be relevant to that household.

To create this logic, I used [custom Hooks in React](https://react.dev/learn/reusing-logic-with-custom-hooks) to get the households (sure I will need them in multiple places) and [React Context](https://react.dev/learn/passing-data-deeply-with-context) to wrap the app in I can access that active household data from anywhere within the app with ease.

First, I created a household-based hook to encapsulate the logic of where to search for households. If the user is authenticated, pull from the remote database, otherwise get it locally:

```typescript
import { useUser } from "@/hooks/useUser";
import { dexie } from "@/dexie-db";
import { api } from "@/utils/trpc";
import { useQuery } from "@tanstack/react-query";
import { useLiveQuery } from "dexie-react-hooks";

export function useHouseholds() {
  const { data: user } = useUser();

  const { data: remoteHouseholds = [], isLoading: isLoadingRemote } = useQuery({
    ...api.household.list.queryOptions(),
    enabled: !!user,
  });

  const localHouseholds = useLiveQuery(() => dexie.households.toArray()) || [];
  const isLoadingLocal = !localHouseholds;

  const households = user ? remoteHouseholds : localHouseholds;
  const householdsLoading = user ? isLoadingRemote : isLoadingLocal;

  return { households, householdsLoading };
}
```

This allowed me to use the household data in various places easily.

```typescript
import { createContext, useContext, useState, useEffect } from "react";
import type { Tables } from "@/database.types";
import { useHouseholds } from "@/hooks/useHouseholds";

type Household = Tables<"households">;

interface ActiveHouseholdContextType {
  activeHousehold: Household | null;
  setActiveHousehold: (household: Household | null) => void;
}

const ActiveHouseholdContext = createContext<ActiveHouseholdContextType | null>(
  null,
);

export function ActiveHouseholdProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const [activeHousehold, setActiveHousehold] = useState<Household | null>(
    null,
  );
  const { households, householdsLoading } = useHouseholds();

  useEffect(() => {
    if (!householdsLoading && households.length > 0 && !activeHousehold) {
      setActiveHousehold(households[0]);
    }
  }, [households, householdsLoading, activeHousehold]);

  return (
    <ActiveHouseholdContext.Provider
      value={{ activeHousehold, setActiveHousehold }}
    >
      {children}
    </ActiveHouseholdContext.Provider>
  );
}

export function useActiveHousehold() {
  const context = useContext(ActiveHouseholdContext);
  if (!context) {
    throw new Error(
      "useActiveHousehold must be used within an ActiveHouseholdProvider",
    );
  }
  return context;
}
```

Then I wrap the app in the context to make the hook usable:

```tsx
{
    path: "/",
    element: (
      <QueryClientProvider client={queryClient}>
        <ActiveHouseholdProvider>
          <App />
        </ActiveHouseholdProvider>
      </QueryClientProvider>
    ),
    children: [
      {
        path: "/",
        index: true,
        element: <Home />,
      },
      {
        path: "/inventory",
        element: <Inventory />,
      },
      {
        path: "/shopping",
        element: <Shopping />,
      },
      {
        path: "/members",
        element: (
          <RequireSignin>
            <Members />
          </RequireSignin>
        ),
      },
      {
        path: "/settings",
        element: <Settings />,
      },
    ],
  },
  {
    path: "*",
    element: <NotFound />,
  },
```

So now, from anywhere within the client side of the application, I can use this hook to get access to the active household and the ability to update it:

```typescript
const { activeHousehold, setActiveHousehold } = useActiveHousehold();
```

And this is the lions share of what needed to happen. 

With these changes, I now have a framework for building out new features and having them operate differently based on whether or not a user is authenticated, all while keeping types coupled, which also keeps testing easy.

## Managing Items By Quantity, Status, and Sometimes Both

One of the biggest reasons for this product to exist is item management. The overall goal is to be able to easily keep track of items and have your shopping list automatically populated based on the current status of an item against whatever user-defined threshold chosen for that item. 

To bring the experience to life, users should be able to create items and track them by quantity, status, or a hybrid of both, and add a shopping list threshold for that item by the appropriate quantity or status.

To get all of this information, I need to use a form. And this is a space where I most definitely have some favorite libraries that make life less challenging when it comes to making complex forms. 

I love using [React Hook Form](https://www.react-hook-form.com/) for form management and [Zod](https://zod.dev/) for input validation. It's great that they're both already included in [the Form component from shadcn/ui](https://ui.shadcn.com/docs/components/form), to get me up and running a little quicker.

In order to create an item, there are a few scenarios I needed to consider in order to build a flexible form. The first thing that required some thinking on the approach was how to handle the item tracking. I started off with quantity management first, since that's the one that hooks into the hybrid tracking experience.

Considerations for quantity-led item tracking:

- The user should be able to set a quantity-based threshold to signal this item needs to be added to the shopping list
- Users should be able to opt-in on hybrid tracking
- If the user opts-in on hybrid tracking but the current item quantity is anything other than 1, they should be able to submit with just that value
- But, if the user opts-in on hybrid tracking and the item count is exactly 1, they're required to also enter the current status of the item to submit

Considerations for status-led item tracking:

- The user should be able to choose the current status of their item
- The user should also be able to choose a threshold value (that is not "FULL") at which the item gets added to the list and remains on the list while any status "at" or "below" the chosen status

The first thing I did was create a schema to manage this form with. This allows me to make rules about the form to keep the user within the guard rails of the logic.

```typescript
const ADD_ITEM_FORM_SCHEMA = z
  .object({
    name: z
      .string()
      .min(ADD_ITEM_FORM_CONSTANTS.name.min, {
        message: `Name must be at least ${ADD_ITEM_FORM_CONSTANTS.name.min} characters`,
      })
      .max(ADD_ITEM_FORM_CONSTANTS.name.max, {
        message: `Name must be less than ${ADD_ITEM_FORM_CONSTANTS.name.max} characters`,
      }),
    quantity: z
      .number()
      .min(ADD_ITEM_FORM_CONSTANTS.quantity.min)
      .max(ADD_ITEM_FORM_CONSTANTS.quantity.max)
      .nullable(),
    status: z.enum(Constants.public.Enums.ITEM_STATUS).nullable(),
    hybridTracking: z.boolean(),
    hybrid_status: z.enum(Constants.public.Enums.ITEM_STATUS).nullable(),
    activeTab: z.enum(TRACKING_METHODS),
    notes: z.string().nullable(),
    shopping_threshold_quantity: z.number().nullable(),
    shopping_threshold_status: z.enum(ITEM_STATUSES_WITHOUT_FULL).nullable(),
  })
  .superRefine((data, ctx) => {
    if (data.activeTab === "QUANTITY" && data.quantity === null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Please enter a quantity",
        path: ["quantity"],
      });
    }
    if (data.activeTab === "STATUS" && data.status === null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: "Please select a status",
        path: ["status"],
      });
    }
    if (
      data.activeTab === "QUANTITY" &&
      data.quantity === 1 &&
      data.hybridTracking &&
      data.hybrid_status === null
    ) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message:
          "Please select a hybrid status when quantity is 1 and hybrid tracking is enabled",
        path: ["hybrid_status"],
      });
    }
  });
```

With that schema, the form is now type-safe. To submit the form, there are a few things I worked into this logic:

1. If an item is status-based, some of the properties from the form that are specific to quantity-based items need to be nullified.
2. If an item is quantity-based, nullify the status-based properties and if the item count is 1 and the user wants hybrid tracking, then we include the status to be the hybrid status they've chosen. Later in the UI, when the user updates that item to be anything other than 1, the status will be removed from the item.

The rest is just a quick check for the user and, if they are authenticated, it will send the call to the API layer and (assuming no issues) save to the database. If the user is not authenticated, we'll be using on-device storage to keep track of their items.

```tsx
interface ItemFormProps {
  onSuccess: () => void;
  // Take in an optional item for editing items
  item?: Tables<"household_items">;
}

const ItemForm = ({ onSuccess, item }: ItemFormProps) => {
  const { data: user } = useUser();
  const createItemMutation = useMutation(api.item.create.mutationOptions());
  const updateItemMutation = useMutation(api.item.update.mutationOptions());
  
  // The hook created to always know the active household
  const { activeHousehold } = useActiveHousehold();

  // Default values from either the item or fallbacks
  const form = useForm<z.infer<typeof ADD_ITEM_FORM_SCHEMA>>({
    resolver: zodResolver(ADD_ITEM_FORM_SCHEMA),
    defaultValues: {
      name: item?.name ?? "",
      quantity: item?.quantity ?? 0,
      status: item?.status ?? "FULL",
      hybridTracking: item?.hybrid_tracking ?? false,
      hybrid_status: item?.status ?? "FULL",
      activeTab: item?.primary_tracking_method ?? "QUANTITY",
      notes: item?.notes ?? null,
      shopping_threshold_quantity: item?.shopping_threshold_quantity ?? 1,
      shopping_threshold_status:
        (item?.shopping_threshold_status as (typeof ITEM_STATUSES_WITHOUT_FULL)[number]) ??
        "LOW",
    },
  });

  const onSubmit = async (values: z.infer<typeof ADD_ITEM_FORM_SCHEMA>) => {
    const activeTab = values.activeTab;

    const submissionValues = {
      ...values,
      ...(activeTab === "STATUS" && {
        quantity: null,
        hybridTracking: false,
        shopping_threshold_quantity: null,
        status: values.status,
      }),
      ...(activeTab === "QUANTITY" && {
        shopping_threshold_status: null,
        quantity: values.quantity,
        status:
          values.quantity === 1 && values.hybridTracking
            ? values.hybrid_status
            : null,
      }),
    };

    if (!activeHousehold) {
      throw new Error("No active household");
    }

    try {
      if (user) {
        if (item) {
          // Update the item that was passed to the form
          await updateItemMutation.mutateAsync({
            id: item!.id,
            name: submissionValues.name,
            quantity: submissionValues.quantity,
            household_id: activeHousehold.id,
            hybrid_tracking: submissionValues.hybridTracking,
            status: submissionValues.status,
            shopping_threshold_quantity:
              submissionValues.shopping_threshold_quantity,
            shopping_threshold_status:
              submissionValues.shopping_threshold_status,
            primary_tracking_method: submissionValues.activeTab,
          });
        } else {
          // Create a new item
          await createItemMutation.mutateAsync({
            name: submissionValues.name,
            quantity: submissionValues.quantity,
            household_id: activeHousehold.id,
            hybrid_tracking: submissionValues.hybridTracking,
            status: submissionValues.status,
            shopping_threshold_quantity:
              submissionValues.shopping_threshold_quantity,
            shopping_threshold_status:
              submissionValues.shopping_threshold_status,
            primary_tracking_method: submissionValues.activeTab,
          });
        }
      } else {
        // Dexie operations
        if (item) {
          await dexie.household_items.update(item.id, {
            last_updated_at: new Date().toISOString(),
            last_updated_by: "local-user",
            name: submissionValues.name,
            quantity: submissionValues.quantity,
            hybrid_tracking: submissionValues.hybridTracking,
            status: submissionValues.status,
            notes: submissionValues.notes,
            shopping_threshold_quantity:
              submissionValues.shopping_threshold_quantity,
            shopping_threshold_status:
              submissionValues.shopping_threshold_status,
            primary_tracking_method: submissionValues.activeTab,
          });
        } else {
          await dexie.household_items.add({
            created_at: new Date().toISOString(),
            household_id: activeHousehold.id,
            last_updated_at: new Date().toISOString(),
            last_updated_by: "local-user",
            name: submissionValues.name,
            quantity: submissionValues.quantity,
            hybrid_tracking: submissionValues.hybridTracking,
            status: submissionValues.status,
            notes: submissionValues.notes,
            shopping_threshold_quantity:
              submissionValues.shopping_threshold_quantity,
            shopping_threshold_status:
              submissionValues.shopping_threshold_status,
            primary_tracking_method: submissionValues.activeTab,
          });
        }
      }
      onSuccess();
    } catch (error) {
      // Adding toasts here later for user feedback in the event of an error.
      console.error("Failed to save item:", error);
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-8">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Item Name</FormLabel>
              <FormControl>
                <Input placeholder="Chocolate milk" {...field} />
              </FormControl>
              <FormDescription>This is the name of the item.</FormDescription>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="activeTab"
          render={({ field }) => (
            <FormItem>
              <FormLabel className="mb-2">Track this item by...</FormLabel>
              <Tabs
                value={field.value}
                onValueChange={(value) => {
                  const newValue = value as "QUANTITY" | "STATUS";
                  if (item && item.primary_tracking_method !== newValue) {
                    form.setValue("activeTab", newValue, { shouldDirty: true });
                  } else {
                    form.setValue("activeTab", newValue, {
                      shouldDirty: false,
                    });
                  }
                }}
              >
                <TabsList className="mb-4 w-full">
                  <TabsTrigger value="QUANTITY">Quantity</TabsTrigger>
                  <TabsTrigger value="STATUS">Status</TabsTrigger>
                </TabsList>

                <TabsContent value="QUANTITY">
                  <div className="space-y-4">
                    <FormField
                      control={form.control}
                      name="quantity"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Item Quantity</FormLabel>
                          <FormControl>
                            <Input
                              type="number"
                              min={0}
                              value={field.value ?? ""}
                              onChange={(e) =>
                                field.onChange(
                                  e.target.value === ""
                                    ? null
                                    : Number(e.target.value),
                                )
                              }
                            />
                          </FormControl>
                          <FormDescription>
                            This is your current item quantity.
                          </FormDescription>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={form.control}
                      name="hybridTracking"
                      render={({ field }) => (
                        <FormItem className="flex flex-row items-start space-y-0 rounded-md border p-4">
                          <FormControl>
                            <Checkbox
                              checked={field.value}
                              onCheckedChange={field.onChange}
                            />
                          </FormControl>
                          <div className="space-y-1 leading-none">
                            <FormLabel>Use hyrbid tracking</FormLabel>
                            <FormDescription>
                              When only <strong>one</strong> is left, start
                              tracking this item by status.
                            </FormDescription>
                          </div>
                        </FormItem>
                      )}
                    />
                    {form.watch("activeTab") === "QUANTITY" &&
                      form.watch("quantity") === 1 &&
                      form.watch("hybridTracking") && (
                        <FormField
                          control={form.control}
                          name="hybrid_status"
                          render={({ field }) => (
                            <FormItem>
                              <FormLabel>
                                Current Status (Hybrid Mode)
                              </FormLabel>
                              <Select
                                onValueChange={field.onChange}
                                value={field.value as string | undefined}
                              >
                                <FormControl>
                                  <SelectTrigger className="w-full">
                                    <SelectValue placeholder="Select a status" />
                                  </SelectTrigger>
                                </FormControl>
                                <SelectContent>
                                  {Constants.public.Enums.ITEM_STATUS.map(
                                    (status) => (
                                      <SelectItem key={status} value={status}>
                                        {status.charAt(0).toUpperCase() +
                                          status.slice(1).toLowerCase()}
                                      </SelectItem>
                                    ),
                                  )}
                                </SelectContent>
                              </Select>
                              <FormDescription>
                                Since you're using hybrid tracking and there's
                                only one of this item, what's it's current
                                status?
                              </FormDescription>
                              <FormMessage />
                            </FormItem>
                          )}
                        />
                      )}
                    <FormField
                      control={form.control}
                      name="shopping_threshold_quantity"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Shopping List Threshold</FormLabel>
                          <FormControl>
                            <Input
                              type="number"
                              min={0}
                              value={field.value ?? ""}
                              onChange={(e) =>
                                field.onChange(
                                  e.target.value === ""
                                    ? null
                                    : Number(e.target.value),
                                )
                              }
                            />
                          </FormControl>
                          <FormDescription>
                            When this item quantity falls to or below this
                            number, it will automatically be added to your
                            shopping list so you can restock before running out
                            completely.
                          </FormDescription>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>
                </TabsContent>

                <TabsContent value="STATUS">
                  <div className="space-y-6">
                    <FormField
                      control={form.control}
                      name="status"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Current Status</FormLabel>
                          <Select
                            onValueChange={field.onChange}
                            value={field.value as string | undefined}
                          >
                            <FormControl>
                              <SelectTrigger className="w-full">
                                <SelectValue placeholder="Select a status" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent>
                              {Constants.public.Enums.ITEM_STATUS.map(
                                (status) => (
                                  <SelectItem key={status} value={status}>
                                    {status.charAt(0).toUpperCase() +
                                      status.slice(1).toLowerCase()}
                                  </SelectItem>
                                ),
                              )}
                            </SelectContent>
                          </Select>
                          <FormDescription>
                            This is the current status of the item.
                          </FormDescription>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <FormField
                      control={form.control}
                      name="shopping_threshold_status"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Shopping List Threshold Status</FormLabel>
                          <Select
                            onValueChange={field.onChange}
                            value={field.value as string | undefined}
                          >
                            <FormControl>
                              <SelectTrigger className="w-full">
                                <SelectValue placeholder="Select a status" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent>
                              {ITEM_STATUSES_WITHOUT_FULL.map((status) => (
                                <SelectItem key={status} value={status}>
                                  {status.charAt(0).toUpperCase() +
                                    status.slice(1).toLowerCase()}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                          <FormDescription>
                            This item will be added to your shopping list when
                            its status is at or below the threshold you set
                            (e.g., 'Low' adds it at 'Low' or 'Out').
                          </FormDescription>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>
                </TabsContent>
              </Tabs>
            </FormItem>
          )}
        />

        <div className="flex justify-end">
          <Button disabled={!form.formState.isDirty} type="submit">
            {item ? "Save Changes" : "Add Item"}
          </Button>
        </div>
      </form>
    </Form>
  );
};

export default ItemForm;
```

With this, we get a single form that handles every scenario for adding and updating items the user wants to manage. 
